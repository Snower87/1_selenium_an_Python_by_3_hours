=**= 2.6 Освобождение ресурсов =**= 
"""
@pytest.fixture(scope="function")
def driver():
    # создание объекта WebDriver
    driver = webdriver.Chrome()
    yeld driver
    # освобождение ресурсов
    browser.quit()    
"""



=**= ﻿3.3 Локаторы =**=

# 3.3 Список основных локаторов
"""
- ID,
- NAME,
- LINK_TEXT,
- PARTIAL_LINK_TEXT,
- TAG_NAME,
- CLASS_NAME,
- CSS_SELECTOR,
- XPATH.
"""

<button id="btnID"
        name="getUsers"
	class="btn-info">
    Кнопка
</button>

d = webdriver. Chrome ()
btn = d.find_element (By.ID, 'btnID')  # поиск по id (стабильный вариант)
btn = d.find_element (By.NAME, 'getUsers')  #()
btn = d.find_element (By.CLASS_NAME, 'btn-info')  # поиск по названию класса
btn = d.find_element (By.TAG_NAME, 'button')  # поиск по названию html-тега
btns = d.find_elements (By.TAG_NAME, 'button')  # поиск списка элементов

-------------------------------------------------
﻿
<div>
	<a href="...">apple</a>
	<a href="...">banana, orange, eggplant</a> 
</div>

d = webdriver.Chrome ()
link = d.find_element (By.LINK_TEXT, 'apple')  # поиск гиперссылок
links = d.find_element (By.PARTIAL_LINK_TEXT, eggplant')  # поиск по частичному совпадению текста гиперссылок


=**= 3.5 Приоритет локаторов =**= ﻿
Приоритет локаторов

1. ID (наивысший приоритет) 
- Уникальный идентификатор элемента Быстрый и надежный доступ к элементам
2. Name (высокий приоритет)
- Имя элемента
- Хороший вариант, если имя уникально
3. CLASS_NAME и TAG_NAME (средний приоритет)
- Используются для групп элементов с одинаковым классом
или тегом
- Могут вызвать неоднозначность при широком использовании на странице
4. LINK_TEXT и PARTIAL_LINK_TEXT (средний приоритет)
- Поиск ссылок по тексту или частичному тексту Эффективны при уникальном тексте ссылки
5. СЅЅ_SELECTOR (низкий приоритет) 
- Требует опыта для создания эффективных селекторов Используйте, когда другие локаторы не подходят
6. ХРАТН (самый низкий приоритет)
- Гибкий, но может быть сложным и медленным 
- Используйте, если другие локаторы не обеспечивают требуемую точность

!﻿Рекомендации!
• Начинайте с высокоприоритетных локаторов (ID, Name)
• Используйте среднеприоритетные локаторы при необходимости (CLASS_NAME, TAG_NAME, LINK_TEXT, PARTIAL_LINK_TEXT)
• Старайтесь избегать низкоприоритетных локаторов, если возможно (СЅS_SELECTOR, ХРАТН)
• Обучайтесь и развивайте навыки написания
эффективных локаторов


=**= 3.6 CSS_SELECTOR =**=

﻿Особенности:
- Гибкий и точный локатор для выбора элементов на веб-странице
- Низкий приоритет по сравнению с другими локаторами
- Рекомендуется использовать в определенных случаях

??? Когда использовать?
- Другие локаторы не обеспечивают точность или не подходят
- Сложный поиск элементов (атрибуты, псевдоклассы, псевдоэлементы) 
- Работа с динамическими веб-страницами
﻿
Примеры:
d = webdriver.Chrome()
d.find_element(By.CSS_SELECTOR, '.example-class')    ---> По классу
d.find_element(By.CSS_SELECTOR, '#example-id')       ---> По идентификатору
d.find_element(By.CSS_SELECTOR, 'input[type="text"]') ---> По атрибуту
d.find_element(By.CSS_SELECTOR, 'div > p')            ---> Дочерний элемент


=**= 3.7 XPATH =**=
 
﻿﻿Особенности:
- Гибкий и точный локатор для выбора элементов на веб-странице
- Низкий приоритет по сравнению с другими локаторами
- Рекомендуется использовать в определенных случаях

??? Когда использовать?
• Другие локаторы не обеспечивают точность или не подходят
• Сложный поиск элементов (текстовое содержимое, положение в DOM-дереве, отношения между элементами)
• Работа с ХМL-документами или веб-страницами с преимущественно XML-структурой
﻿
Примеры
d = webdriver.Chrome()
d.find_element(By.XPATH, '//input[@type="text"]')		---> По атрибуту
d.find_element(By.ХРАТН, '//div[contains(text(), "Пример")]')	---> По текстовому содержимому
d.find_element(By.XPATH, '//div/p')				---> Дочерний элемент
d.find_element(By.XPATH, '//div[@id="example-id"]/following-sibling::div') ---> Элемент относительно другого элемента
﻿
XPATH
Плюсы и минусы
+ Гибкость
+ Работа с ХML-структурой
+ Поддержка осей, функций и условных выражений
+ Выборка нескольких элементов

- Зависимость от структуры DOM
- Сложный и длинный синтаксис
- Производительность

=**= 3.8 Взаимодействие с input-элементами =**= 
﻿
Input Elements
• ТЕХТ. используются для ввода текстовой информации, такой как имя пользователя или почтовый адрес
• PASSWORD. аналогичны текстовым полям, но скрывают введенные символы для обеспечения безопасности
• CHECKBOX. позволяют пользователю выбрать одну или несколько опций из предложенного списка
• RADIO. аналогичны чекбоксам, но предоставляют возможность выбора только одной опции из списка
• SELECT. позволяют выбрать одну опцию из списка, обычно представленного в виде раскрывающегося меню

﻿Пример <input>:
<input type="text" id="firstName">

d = webdriver.chrome ()
first_name = d.find_element (By.ID, 'firstName')  ---> Поиск по ID
first_name.send_keys('Вася')		---> Ввод текста
first_name.send_keys (Keys.ENTER)	---> Ввод специальных символов
first_name.clear()			---> Очистить поле

﻿﻿Пример <select>:
<select_id="city">
  <option value="s1">Москва</option>
  <option value="s2">Санкт-Петербург</option> 
  <option value="s3">Краснодар</option>
</select>

d = webdriver.Chrome ()
el = d.find_element(By.ID, 'city')	---> Поиск по ID
x = Select(el)				---> Создание объекта селектора
x.select_by_visible_text('Москва')	---> Выбрать элемент по тексту
x.select_by_index(0)			---> Выбрать элемент по индексу

﻿﻿Пример <checkbox>:﻿
<input type="checkbox" id="rememberData">
d = webdriver.Chrome ()
el d.find_element (By. ID, 'rememberData')	---> Поиск по ID
el.click()					---> Выбрать кликом

﻿﻿﻿Пример <radiobutton>:﻿
<input type="radio" id="Yes"> 
<input type="radio" id="No">
d = webdriver. Chrome ()
r1 = d.find_element (By.ID, 'Yes') ---> Поиск по ID
R2 = d.find_element (By.ID, 'No')

r1.click() r2.click()	--->  Выбран элемент1 / не выбран элемент2

﻿Еще примеры методов <radiobutton>:﻿
r1.is_selected()	---> Вернет True, если элемент выбран
r1.is_enabled ()	---> Вернет True, если элемент включен
r1.is_displayed()	---> Вернет True, если элемент отображен


=**= ﻿3.9 Работа с динамическими веб-страницами =**=
Динамичные веб-страницы:
1. AJAX
технология, которая позволяет веб-страницам выполнять асинхронные запросы к серверу и получать данные без перезагрузки страницы. В результате, элементы на странице могут обновляться динамически по мере получения новых данных
2. WebSockets
протокол, который обеспечивает двунаправленное взаимодействие между клиентом и сервером через
постоянное соединение. WebSockets позволяют передавать данные в реальном времени, что приводит к динамическому обновлению элементов на странице

Timeout
1. Implicit Wait - Неявное ожидание (задается настройками веб-драйвера)
- Общий тайм-аут для всех операций поиска элементов
- Применяется ко всем операциям поиска в WebDriver

Пример №1:
from selenium import webdriver

driver = webdriver.Chrome()
driver.implicitly_wait(10) # Задаем неявное ожидание 10 секунд
driver.get("http://example.com") # Ваши действия и поиск элементов здесь
driver.quit()

2. Explicit Wait - Явное ожидание ()
- Таймаут и условие для конкретного элемента или операции 
- Больше гибкости и контроля над процессом ожидания

Пример №2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome() driver.get("http://example.com")
wait = WebDriverWait(driver, 10)

element = wait.until(EC.visibility_of_element_located((By.ID, "dynamic-elemt')
# Ваши действия с элементом здесь

driver.quit()


= Примеры таких методов =
﻿
el = WebDriverWait (browser, timeout=2). until (EC.visibility_of_element_located ((ID, 'btnID')))

• title_is()
• title_contains()
• presence_of_element_located()
• visibility_of_element_located()
• invisibility_of_element_located()
• visibility_of()


== Timeout. Рекомендации ==
+ Использовать неявные ожидания для общего таймаута поиска элементов
+ Использовать явные ожидания для индивидуальных таймаутов и условий
+ Избегать одновременного использования неявных и явных ожиданий
+ Тестировать ожидания и их влияние на стабильность тестов


=**= 4.1 Взаимодействие с вкладками и окнами =**= 
﻿
- Веб-сайт может открывать ссылки в новых вкладках и окнах
- Иногда переключение между вкладками и окнами - обязательно
- Иногда необходимо открыть новые вкладки или окна для того, чтобы убедится, что ничего не поломалось

﻿
= Взаимодействие с вкладками и окнами =

d = webdriver.Chrome()

original_handler = d.current_window_handle  ---> Сохранить текущую страницу
d.switch_to.window(original_handler) 	    ---> Переключиться на новую вкладку/окно
d.close() 			  ---> Закрыть текущую вкладку/окно
d.switch_to.new_window('tab') 	  ---> Создать новую вкладку
d.switch_to.new_window('window')  ---> Создать новое окно


=**= 4.2 Изменение расположения и размера окна браузера =**= 
﻿
Изменение расположения и размера окна браузера:
d = webdriver.Chrome ()
d.set_window_size(1024, 768)  	---> Устанавливать ширину и высоту окна браузера
d.maximize_window()  	 	---> Максимизировать окно
d.minimize_window()  		---> Минимизировать окно
d.get_window_size()  		---> Узнать текущий размер окна
d.set_window_position(100, 200) ---> Установить координаты верхнего левого угла окна браузера
d.save_screenshot('./image')  	---> Сделать снимок экрана


=**= 4.3 Headless Mode в Selenium WebDriver =**=




